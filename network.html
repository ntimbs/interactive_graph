<!-- ====== NETWORK GRAPH (Squarespace-ready, D3 v7) ====== -->
<div id="network-graph" style="width:100%;max-width:1000px;margin:0 auto;"></div>

<!-- Optional: put your data here as JSON so non-devs can edit it -->
<script type="application/json" id="graph-data">
{
  "nodes": [
    { "id": "A", "group": "People", "label": "Alice" },
    { "id": "B", "group": "People", "label": "Bob" },
    { "id": "C", "group": "Topics", "label": "NDCG" },
    { "id": "D", "group": "Topics", "label": "mAP" },
    { "id": "E", "group": "Topics", "label": "MMR" }
  ],
  "links": [
    { "source": "A", "target": "C", "weight": 1 },
    { "source": "A", "target": "D", "weight": 2 },
    { "source": "B", "target": "C", "weight": 3 },
    { "source": "B", "target": "E", "weight": 1 },
    { "source": "C", "target": "D", "weight": 2 },
    { "source": "C", "target": "E", "weight": 1 }
  ]
}
</script>

<!-- D3 from a CDN (allowed in Squarespace code blocks) -->
<script src="https://unpkg.com/d3@7"></script>

<style>
/* Clean default style; tweak as desired */
#network-graph .node circle { stroke: #fff; stroke-width: 1.25px; }
#network-graph .node text   { font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; pointer-events:none; }
#network-graph .link        { stroke: #999; stroke-opacity: .6; }
#network-graph .link.highlight { stroke-opacity: 0.95; }
#network-graph .node.highlight circle { stroke: #111; stroke-width: 2px; }
#network-graph .tooltip {
  position: absolute; pointer-events: none; padding: 6px 8px; border-radius: 6px;
  background: rgba(20,20,20,.9); color: #fff; font: 12px/1.3 system-ui; transform: translate(-50%, calc(-100% - 10px));
  white-space: nowrap; z-index: 20;
}
#network-graph .legend {
  display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin: 8px 0 4px;
  font: 12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
}
#network-graph .legend-item { display:flex; gap:6px; align-items:center; }
#network-graph .legend-swatch { width:12px; height:12px; border-radius:50%; border:1px solid rgba(0,0,0,.15);}
</style>

<script>
(function() {
  const container = document.getElementById('network-graph');

  // Read data from the JSON <script> tag
  const raw = document.getElementById('graph-data');
  const data = raw ? JSON.parse(raw.textContent) : { nodes: [], links: [] };

  // Color by 'group'
  const groups = [...new Set(data.nodes.map(n => n.group || 'Other'))];
  const color = d3.scaleOrdinal()
    .domain(groups)
    .range(d3.schemeTableau10.concat(d3.schemeSet3)); // plenty of distinct colors

  // Dimensions (keeps a nice aspect; auto-resizes)
  const width  = Math.min(container.clientWidth || 800, 1000);
  const height = Math.round(width * 0.62);

  // Root wrapper (so we can overlay legend & tooltip)
  container.style.position = 'relative';

  // Legend
  const legend = document.createElement('div');
  legend.className = 'legend';
  legend.innerHTML = groups.map(g =>
    `<div class="legend-item">
       <span class="legend-swatch" style="background:${color(g)}"></span>${g}
     </div>`).join('');
  container.appendChild(legend);

  // Tooltip
  const tooltip = document.createElement('div');
  tooltip.className = 'tooltip';
  tooltip.style.display = 'none';
  container.appendChild(tooltip);

  // SVG + zoom/pan
  const svg = d3.select(container).append('svg')
    .attr('viewBox', [0, 0, width, height])
    .attr('width', '100%')
    .attr('height', 'auto')
    .style('cursor', 'grab');

  const g = svg.append('g'); // zoom target

  const zoom = d3.zoom()
    .scaleExtent([0.3, 4])
    .on('zoom', (event) => g.attr('transform', event.transform));
  svg.call(zoom);

  // Force simulation
  const sim = d3.forceSimulation(data.nodes)
    .force('link', d3.forceLink(data.links).id(d => d.id).distance(l => 30 + (l.weight ? 60 / l.weight : 40)).strength(0.6))
    .force('charge', d3.forceManyBody().strength(-180))
    .force('center', d3.forceCenter(width / 2, height / 2))
    .force('collide', d3.forceCollide().radius(d => 18).iterations(2));

  // Draw links
  const link = g.append('g')
    .attr('stroke-linecap', 'round')
    .selectAll('line')
    .data(data.links)
    .join('line')
    .attr('class', 'link')
    .attr('stroke-width', d => Math.max(1, Math.min(6, d.weight ? d.weight : 1)));

  // Draw nodes (circle + label)
  const node = g.selectAll('.node')
    .data(data.nodes)
    .join('g')
    .attr('class', 'node')
    .call(drag(sim));

  node.append('circle')
    .attr('r', 8)
    .attr('fill', d => color(d.group || 'Other'));

  node.append('text')
    .attr('x', 10)
    .attr('y', 3)
    .text(d => d.label || d.id)
    .attr('fill', '#111');

  // Hover interactions (highlight neighbors)
  const neighbors = buildNeighborMap(data.nodes, data.links);

  node.on('mouseenter', function(event, d) {
      svg.style('cursor', 'pointer');
      showTooltip(event, d);
      setHighlight(d, true);
    })
    .on('mousemove', (event, d) => showTooltip(event, d))
    .on('mouseleave', function(event, d) {
      svg.style('cursor', 'grab');
      tooltip.style.display = 'none';
      clearHighlight();
    });

  // Tick update
  sim.on('tick', () => {
    link.attr('x1', d => d.source.x)
        .attr('y1', d => d.source.y)
        .attr('x2', d => d.target.x)
        .attr('y2', d => d.target.y);

    node.attr('transform', d => `translate(${d.x},${d.y})`);
  });

  // ----- helpers -----
  function drag(simulation) {
    function dragstarted(event, d) {
      if (!event.active) simulation.alphaTarget(0.25).restart();
      d.fx = d.x; d.fy = d.y;
    }
    function dragged(event, d) {
      d.fx = event.x; d.fy = event.y;
    }
    function dragended(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null; d.fy = null;
    }
    return d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended);
  }

  function buildNeighborMap(nodes, links) {
    const map = new Map(nodes.map(n => [n.id, new Set([n.id])]));
    links.forEach(l => {
      map.get(l.source.id ? l.source.id : l.source).add(l.target.id ? l.target.id : l.target);
      map.get(l.target.id ? l.target.id : l.target).add(l.source.id ? l.source.id : l.source);
    });
    return map;
  }

  function setHighlight(d, on) {
    const nset = neighbors.get(d.id) || new Set();
    node.classed('highlight', n => nset.has(n.id));
    link.classed('highlight', l => nset.has(l.source.id) && nset.has(l.target.id));
    node.select('circle').attr('opacity', n => nset.has(n.id) ? 1 : 0.25);
    node.select('text').attr('opacity', n => nset.has(n.id) ? 1 : 0.25);
    link.attr('opacity', l => (nset.has(l.source.id) && nset.has(l.target.id)) ? 0.95 : 0.15);
  }
  function clearHighlight() {
    node.classed('highlight', false);
    link.classed('highlight', false).attr('opacity', 0.6);
    node.select('circle').attr('opacity', 1);
    node.select('text').attr('opacity', 1);
  }

  function showTooltip(event, d) {
    const html = `
      <strong>${escapeHtml(d.label || d.id)}</strong><br/>
      <span style="opacity:.8">${escapeHtml(d.group || 'Unlabeled')}</span>
    `;
    tooltip.innerHTML = html;
    tooltip.style.left = event.clientX + 'px';
    tooltip.style.top = (event.clientY - 16) + 'px';
    tooltip.style.display = 'block';
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  // Responsive: re-fit on resize (keeps current zoom)
  new ResizeObserver(() => {
    const w = Math.min(container.clientWidth || width, 1200);
    const h = Math.round(w * 0.62);
    svg.attr('viewBox', [0, 0, w, h]);
    sim.force('center', d3.forceCenter(w/2, h/2)).alpha(0.1).restart();
  }).observe(container);

})();
</script>
